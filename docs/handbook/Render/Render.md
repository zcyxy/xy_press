## TCP协议

**TCP: Transmission Control Protocol  传输控制协议** 是一种面向连接的、可靠的、基于字节流的传输层通信协议。

> 1. 客户端发送 syn 包 （syn=j） 到服务器，并进入 SYN_SEND 状态，等待服务器确认。  
> 2. 服务器收到 syn 包，必须确认客户的SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态。  
> 3. 客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK(ack=k+1) ，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。

![TCP](https://gitee.com/xyzcy/blog/raw/master/src/assets/img/tcp.png)

> SYN : synchronous 建立联机  
> ACK : acknowledgement 确认  
> SYN_SENT : 请求连接  
> SYN_RECV : 服务端被动打开后,接收到了客户端的 SYN 并且发送了 ACK 时的状态。再进一步接收到客户端的 ACK 就进入 ESTABLISHED 状态。

## UDP协议

**UDP: User Datagram Protocol  用户数据报协议**

> 相比于 TCP 的面向连接需要反复确认的繁琐步骤，UDP 是一中性格特立独行并且主观性超强的非面向连接的协议，使用 udp 协议经常通信并不需要建立连接，它只是负责把数据尽可能快的发送出去，简单粗暴，并且不可靠，而在接收端，UDP 把每个消息断放入队列中，接收端程序从队列中读取数据。

## HTTP协议

**HTTP协议: Hypertext Transfer Protocol  也叫超文本传送协议** 它是一种基于 TCP/IP 协议栈、在表示层和应用层上的协议（TCP在传输层的协议），通俗一点说就是：

> * TCP/IP 是位于传输层上的一种协议，用于在网络中传输数据；
> * HTTP 协议是应用层协议，基于 TCP 协议，用于包装数据，程序使用它进行通信，可以简单高效的处理通信中数据的传输和识别处理

## URL

**URL: Uniform Resource Locator  统一资源定位符** 说白了就是网络上用来标识具体资源的一个地址，包含了用户查找该资源的信息， HTTP 使用它来传输数据和建立连接

一个 URL 有以下组成部分：

> 1. 协议
> 2. 服务器地址（域名或IP+端口）
> 3. 路径
> 4. 文件名

比如：https://www.baidu.com/index.html

其中

> 1. https:// 是一种协议 当然， HTTP 也是、ftp 也是…
> 2. www.baidu.com 是服务器地址，当然你知道百度的 IP 也可以，例如用 ping 命令得到百度的 ip: 14.215.177.39 ，那么我可以用 http://14.215.177.39 打开百度
> 3. index.html 包含了路径和文件名，当然通常 index.html 是可以省略的，所以打开百度时，并没有看到这个。

## DNS

**DNS: Domain Name Server  域名服务器**

当用户在浏览器输入 https://www.baidu.com 回车时，它经历了以下步骤：

> 1. 浏览器根据地址去本身缓存中查找 dns 解析记录，如果有，则直接返回 IP 地址，否则浏览器会查找操作系统中（hosts文件）是否有该域名的 dns 解析记录，如果有则返回。
> 2. 如果浏览器缓存和操作系统 hosts 中均无该域名的 dns 解析记录，或者已经过期，此时就会向域名服务器发起请求来解析这个域名。
> 3. 请求会先到 LDNS（本地域名服务器），让它来尝试解析这个域名，如果 LDNS 也解析不了，则直接到根域名解析器请求解析
> 4. 根域名服务器给 LDNS 返回一个所查询余的主域名服务器（gTLDServer）地址。
> 5. 此时 LDNS 再向上一步返回的 gTLD 服务器发起解析请求。
> 6. gTLD 服务器接收到解析请求后查找并返回此域名对应的 Name Server 域名服务器的地址，这个 Name Server 通常就是你注册的域名服务器（比如阿里dns、腾讯dns等）
> 7. Name Server 域名服务器会查询存储的域名和 IP 的映射关系表，正常情况下都根据域名得到目标 IP 记录，连同一个 TTL 值返回给 DNS Server 域名服务器
> 8. 返回该域名对应的 IP 和 TTL 值，Local DNS Server 会缓存这个域名和 IP 的对应关系，缓存的时间有 TTL 值控制。
> 9. 把解析的结果返回给用户，用户根据 TTL 值缓存在本地系统缓存中，域名解析过程结束。

## 页面渲染

![页面渲染](https://gitee.com/xyzcy/blog/raw/master/src/assets/img/render.png)

1. **HTML parser**: HTML解析器，其本质是将 HTML 文本解释成 DOM tree。
2. **CSS parser**: CSS解析器，其本质是讲 DOM 中各元素对象加入样式信息
3. **JavaScript引擎**: 专门处理 JavaScript 脚本的虚拟机，其本质是解析 JS 代码并且把逻辑（HTML和CSS的操作）应用到布局中，从而按程序要的要求呈现相应的结果
4. **DOM tree**:文档对象模型树，也就是浏览器通过 HTMLparser 解析 HTML 页面生成的 HTML 树状结构以及相应的接口。
5. **render tree**: 渲染树，也就是浏览器引擎通过 DOM Tree 和 CSS Rule Tree 构建出来的一个树状结构，和 dom tree 不一样的是，它只有要最终呈现出来的内容，像或者带有 display:none 的节点是不存在 render tree 中的。
6. **layout**: 也叫 reflow **回流**（重排），渲染中的一种行为。当 rendertree 中任一节点的几何尺寸发生改变了，render tree 都会重新布局。
7. **repaint**: **重绘**，渲染中的一种行为。render tree 中任一元素样式属性（几何尺寸没改变）发生改变了，render tree 都会重新画，比如字体颜色、背景等变化。

所以，根据关键词汇的解释以及顺着流程图的流程，可以总结出，浏览器解析渲染页面主要包括以下过程：

> 1. 浏览器通过 HTMLParser 根据深度遍历的原则把 HTML 解析成 DOM Tree。
> 2. 将 CSS 解析成 CSS Rule Tree（CSSOM Tree）。
> 3. 根据 DOM 树和 CSSOM 树来构造 render Tree。
> 4. layout: 根据得到的 render tree 来计算所有节点在屏幕的位置。
> 5. paint: 遍历 render 树，并调用硬件图形 API 来绘制每个节点。

## 回流和重绘

### 回流

当我们对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生 **回流** 的过程。

例如以下操作会触发回流：

1. 一个 DOM 元素的几何属性变化，常见的几何属性有 **width、height、padding、margin、left、top、border** 等等, 这个很好理解。
2. 使 DOM 节点发生 **增减** 或者 **移动**。
3. 读写 **offset** 族、 **scroll** 族和 **client** 族属性的时候，浏览器为了获取这些值，需要进行回流操作。
4. 调用 **window.getComputedStyle** 方法。

回流过程：由于 DOM 的结构发生了改变，所以需要从生成 DOM 这一步开始，重新经过 **样式计算、生成布局树、建立图层树、** 再到 **生成绘制列表** 以及之后的显示器显示这整一个渲染过程走一遍，开销是非常大的。

---

### 重绘

当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致 **重绘(repaint)** 。

重绘过程：由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，所以当发生重绘的时候，会跳过 **生存布局树** 和 **建立图层树** 的阶段，直接到 **生成绘制列表** ，然后继续进行分块、生成位图等后面一系列操作。

---

### 如何避免触发回流和重绘

1. 避免频繁使用 style，而是采用修改 **class** 的方式。
2. 将动画效果应用到 **position** 属性为 **absolute** 或 **fixed** 的元素上。
3. 也可以先为元素设置 **display: none** ，操作结束后再把它显示出来。因为在 **display** 属性为 **none** 的元素上进行的 DOM 操作不会引发回流和重绘
4. 使用 **createDocumentFragment** 进行批量的 DOM 操作。
5. 对于 resize、scroll 等进行防抖/节流处理。
6. 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
7. 利用 CSS3 的 **transform**、**opacity**、**filter** 这些属性可以实现合成的效果，也就是 GPU 加速。

## 性能优化

**对于css**:

> 1. 优化选择器路径：健全的 css 选择器固然是能让开发看起来更清晰，然后对于 css 的解析来说却是个很大的性能问题，因此相比于 .a .b .c{} ，更倾向于大家写 .c{}。
> 2. 压缩文件：尽可能的压缩你的 css 文件大小，减少资源下载的负担。
> 3. 选择器合并：把有共同的属性内容的一系列选择器组合到一起，能压缩空间和资源开销
> 4. 精准样式：尽可能减少不必要的属性设置，比如你只要设置 {padding-left:10px} 的值,那就避免 {padding:0 0 0 10px} 这样的写法
> 5. 雪碧图：在合理的地方把一些小的图标合并到一张图中，这样所有的图片只需要一次请求，然后通过定位的方式获取相应的图标，这样能避免一个图标一次请求的资源浪费。
> 6. 避免通配符：.a .b \*{} 像这样的选择器，根据从右到左的解析顺序在解析过程中遇到通配符（*）回去遍历整个dom的，这样性能问题就大大的了。
> 7. 少用 Float:Float 在渲染时计算量比较大，尽量减少使用。
> 8. 0值去单位：对于为0的值，尽量不要加单位，增加兼容性

---

**对于JavaScript**:

> 1. 尽可能把 script 标签放到 body 之后，避免页面需要等待 js 执行完成之后 dom 才能继续执行，最大程度保证页面尽快的展示出来。
> 2. 尽可能合并script代码，
> 3. css 能干的事情，尽量不要用 JavaScript 来干。毕竟 JavaScript 的解析执行过于直接和粗暴，而 css 效率更高。
> 4. 尽可能压缩的 js 文件，减少资源下载的负担
> 5. 尽可能避免在 js 中逐条操作 dom 样式，尽可能预定义好 css 样式，然后通过改变样式名来修改 dom 样式，这样集中式的操作能减少 reflow 或 repaint 的次数。
> 6. 尽可能少的在 js 中创建 dom，而是预先埋到 HTML 中用 display:none 来隐藏，在 js 中按需调用，减少 js 对 dom 的暴力操作。

---

**对于HTML**：

> 1. 避免再 HTML 中直接写 css 代码。
> 2. 使用 Viewport 加速页面的渲染。
> 3. 使用语义化标签，减少 css 的代码，增加可读性和 SEO。
> 4. 减少标签的使用，dom 解析是一个大量遍历的过程，减少无必要的标签，能降低遍历的次数。
> 5. 避免 src、href 等的值为空。
> 6. 减少 dns 查询的次数。