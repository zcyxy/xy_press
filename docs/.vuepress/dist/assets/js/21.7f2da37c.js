(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{428:function(t,v,o){"use strict";o.r(v);var _=o(2),p=Object(_.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"原型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[t._v("#")]),t._v(" 原型")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://gitee.com/xyzcy/blog/raw/master/src/assets/img/1.prototype.png",alt:"prototype"}})]),t._v(" "),v("ol",[v("li",[v("p",[t._v("每一个构造函数都拥有一个 "),v("b",[t._v("prototype")]),t._v(" 属性，这个属性指向一个对象，也就是 "),v("b",[t._v("原型对象")]),t._v(" 。当使用这个构造函数创建实例的时候， "),v("b",[t._v("prototype")]),t._v(" 属性指向的原型对象就成为实例的原型对象。")])]),t._v(" "),v("li",[v("p",[t._v("原型对象默认拥有一个 "),v("b",[t._v("constructor")]),t._v(" 属性，指向指向它的那个构造函数（也就是说构造函数和原型对象是互相指向的关系）。")])]),t._v(" "),v("li",[v("p",[t._v("每个对象都拥有一个隐藏的属性 "),v("b",[t._v("[[prototype]]")]),t._v(" ，指向它的原型对象，这个属性可以通过 "),v("b",[t._v("Object.getPrototypeOf(obj)")]),t._v(" 或 "),v("b",[t._v("obj."),v("strong",[t._v("proto")])]),t._v(" 来访问。")])]),t._v(" "),v("li",[v("p",[t._v("实际上，构造函数的 "),v("b",[t._v("prototype")]),t._v(" 属性与它创建的实例对象的 "),v("b",[t._v("[[prototype]]")]),t._v(" 属性指向的是同一个对象，即 对象 "),v("b",[t._v("."),v("strong",[t._v("proto")])]),t._v(" === "),v("b",[t._v("函数.prototype")]),t._v(" 。")])]),t._v(" "),v("li",[v("p",[t._v("如上文所述，原型对象就是用来存放实例中共有的那部分属性。")])]),t._v(" "),v("li",[v("p",[t._v("在 JavaScript 中，所有的对象都是由它的原型对象继承而来，反之，所有的对象都可以作为原型对象存在。")])]),t._v(" "),v("li",[v("p",[t._v("访问对象的属性时， JavaScript 会首先在对象自身的属性内查找，若没有找到，则会跳转到该对象的原型对象中查找。")])])])])}),[],!1,null,null,null);v.default=p.exports}}]);