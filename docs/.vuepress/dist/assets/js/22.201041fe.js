(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{432:function(t,o,_){"use strict";_.r(o);var r=_(2),v=Object(r.a)({},(function(){var t=this,o=t._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h2",{attrs:{id:"原型"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[t._v("#")]),t._v(" 原型")]),t._v(" "),o("p",[o("img",{attrs:{src:"https://gitee.com/xyzcy/blog/raw/master/src/assets/img/1.prototype.png",alt:"prototype"}})]),t._v(" "),o("ol",[o("li",[o("p",[t._v("每一个构造函数都拥有一个 "),o("strong",[t._v("prototype")]),t._v(" 属性，这个属性指向一个对象，也就是 "),o("strong",[t._v("原型对象")]),t._v(" 。当使用这个构造函数创建实例的时候， "),o("strong",[t._v("prototype")]),t._v(" 属性指向的原型对象就成为实例的原型对象。")])]),t._v(" "),o("li",[o("p",[t._v("原型对象默认拥有一个 "),o("strong",[t._v("constructor")]),t._v(" 属性，指向指向它的那个构造函数（也就是说构造函数和原型对象是互相指向的关系）。")])]),t._v(" "),o("li",[o("p",[t._v("每个对象都拥有一个隐藏的属性 "),o("strong",[t._v("[[prototype]]")]),t._v(" ，指向它的原型对象，这个属性可以通过 "),o("strong",[t._v("Object.getPrototypeOf(obj)")]),t._v(" 或 "),o("strong",[t._v("obj.__proto__")]),t._v(" 来访问。")])]),t._v(" "),o("li",[o("p",[t._v("实际上，构造函数的 "),o("strong",[t._v("prototype")]),t._v(" 属性与它创建的实例对象的 "),o("strong",[t._v("[[prototype]]")]),t._v(" 属性指向的是同一个对象，即 对象 "),o("strong",[t._v(".__proto__")]),t._v(" === "),o("strong",[t._v("函数.prototype")]),t._v(" 。")])]),t._v(" "),o("li",[o("p",[t._v("如上文所述，原型对象就是用来存放实例中共有的那部分属性。")])]),t._v(" "),o("li",[o("p",[t._v("在 JavaScript 中，所有的对象都是由它的原型对象继承而来，反之，所有的对象都可以作为原型对象存在。")])]),t._v(" "),o("li",[o("p",[t._v("访问对象的属性时， JavaScript 会首先在对象自身的属性内查找，若没有找到，则会跳转到该对象的原型对象中查找。")])])])])}),[],!1,null,null,null);o.default=v.exports}}]);